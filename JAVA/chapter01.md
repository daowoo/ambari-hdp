# JVM
## RunTime数据区
|           名称           | 线程共享 |                               作用                                |             设置              |
| ------------------------ | -------- | ----------------------------------------------------------------- | ----------------------------- |
| Method Area              | 共享     | Non-Heap,存放被虚拟机加载的类信息、常量、静态变量、编译后的代码等 | -XX:PermSize、-XX:MaxPermSize |
| Heap                     | 共享     | Heap,大内存区域，几乎所有对象实例都存储在这里，GC管理的主要区域   | -Xms、-Xmx、-Xmn、-XX:NewSize、-XX:MaxNewSize、-XX:PermSize、-XX:MaxPermSize |
| VM Stack                 | 隔离     | 线程私有，每个方法创建一个栈帧，调用过程就是入栈和出栈过程        |                               |
| Native Method Stack      | 隔离     | 与虚拟机栈作用类似，目标是为使用到的Native方法服务                |                               |
| Program Counter Register | 隔离     | 小内存区域，当前线程所执行的字节码的行号指示器                    |                               |

## 对象的创建
Bump the Pointer：指针碰撞，假设JAVA堆中内存是规整的，用过的内存放在一边，空闲的内存放在另一边，中间放着指针作为分界点指示器，那分配内存就仅仅是把指针往空闲空间挪动一段与对象大小相等的距离。
Free List：空闲列表，如果JAVA堆中内存不规整，已使用的内存和空闲的内存相互交错，虚拟机就维护一个空闲列表，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
Thread Local Allocation Buffer：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓存。

## 判断对象已死的算法
|      算法      |                                                          特点                                                          |                不足                |
| -------------- | ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------- |
| 引用计数算法   | 对象被引用时计数值加1，引用失效时计数值减1                                                                             | 难以解决对象之间相互循环引用的问题 |
| 可达性分析算法 | 以‘GC Roots’对象作为起始点开始向下搜索，所走过的路径称为引用链，当对象到'GC Roots'没有任何引用链相连时，则此对象不可用 |  搜索效率，枚一致性保证所引起的GC停顿                                  |

## JAVA引用概念的定义
|  名称  |                         定义                         |                          回收                          |
| ------ | ---------------------------------------------------- | ------------------------------------------------------ |
| 强引用 | 类似Object obj=new Object()的这类引用                | 只要引用关系存在，GC永远不会回收被引用对象             |
| 软引用 | 描述一些还有用但是并非必需的对象                     | 系统将要发生内存溢出之前，对这些对象进行第二次回收     |
| 弱引用 | 也是用来描述非必需的对象，但强度比软引用更弱         | 只能生存到下一次GC发生之前，第一次标记，第二次必定回收 |
| 虚引用 | 最弱的引用关系，对象是否有虚引用完全不影响其生存时间 | 设置虚引用唯一的目的是在GC回收它时收到一个系统通知     |

## GC算法
|     算法      |                                   特点                                   |                        不足                        |
| ------------- | ------------------------------------------------------------------------ | -------------------------------------------------- |
| 标记-清除算法 | 先标记出待回收的对象，然后统一回收所有被标记对象                         | 标记和清除过程效率不高，会产生大量不连续的内存碎片 |
| 复制算法      | 内存分为两块，每次使用一块，回收后将存活的对象复制到另一块，并清空当前块 | 内存缩小为原来的一半，代价太高了                   |
| 标记-整理算法 | 先标记出待回收的对象，然后所有存活对象都向一端移动                       |                                                    |

## 垃圾收集器
|       名称        |                           概念                           |                                  场景                                  |                                                  使用                                                  |
| ----------------- | -------------------------------------------------------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| Serial            | 单线程收集器，工作时必须暂停其他所有用户线程             | JVM Client模式下新生代默认收集器，简单高效，停顿时间可控               | -XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure                              |
| Parnew            | serial的多线程版本，可使用serial的控制参数               | 在服务端与CMS收集器配合，默认的新生代收集器，收集线程个数与CPU数量相同 | -XX:+UseParNewGC、-XX:ParallelGCThreads                                                                |
| Parallel Scavenge | 吞吐量优先的收集器，通过设置停顿时间和吞吐量大小来控制   | 新生代收集器，在注重吞吐量以及CPU资源敏感的场合使用                    | -XX:MaxGCPauseMillis、-XX:GCTimeRatio、-XX:UseAdaptiveSizePolicy                                       |
| Serial Old        | serial的老年代版本，使用“标记-整理”算法                  | 作为CMS的后备预案，在并发收集发生Concurrent Mode Failure时使用         |                                                                                                        |
| Parallel Old      | parallel scavenge的老年版本。使用多线程和“标记-整理”算法 | 搭配parallel scavenge应用在高吞吐量场景                                |                                                                                                        |
| CMS               | 并发收集，低停顿，使用多线程和“标记-清除”算法            | 以获取最短回收停顿时间为目标的收集器，较多的应用在B/S模式的服务端上    | -XX:CMSInitiatingOccupancyFraction、-XX:+UseCMSCompactAtFullCollection、-XX:CMSFullGCsBeforeCompaction |

## 如何查看GC日志
```gc

```

* 最前面的数字代表了GC发生的时间，含义是从jvm启动以来进过的秒数
* 日志开头的‘GC’和‘Full GC’说明了这次垃圾收集的停顿类型，如果有'Full'表明这次GC是发生了Stop-The-World的
* 接下来的‘DefNew’、‘Tenured’、‘Perm’表示GC发生的区域，显示的区域名称与使用的GC收集器是密切相关的
* 后面
